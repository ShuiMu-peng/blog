import{_ as s,c as a,e,o as p}from"./app-CE4jh6_n.js";const o="/blog/kafka.assets/image-20210601084800343.png",t="/blog/kafka.assets/image-20210531084930672.png",c="/blog/kafka.assets/image-20210805192328049.png",l="/blog/kafka.assets/image-20210806082425949.png",i="/blog/kafka.assets/image-20220127114954375.png",u={};function r(d,n){return p(),a("div",null,n[0]||(n[0]=[e(`<h3 id="consumer" tabindex="-1"><a class="header-anchor" href="#consumer"><span>consumer</span></a></h3><p>kafka中的消费，是以组为单位：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"><span class="token comment">#查看消费组的消费偏移量</span></span>
<span class="line"><span class="token comment">#current-offset：当前消费组的已消费偏移量</span></span>
<span class="line"><span class="token comment">#log-end-offset：主题对应分区消息的结束偏移量(HW)</span></span>
<span class="line"><span class="token comment">#lag：当前消费组未消费的消息数</span></span>
<span class="line">bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 <span class="token parameter variable">--describe</span> <span class="token parameter variable">--group</span> testGroup-2</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+o+'" alt="image-20210601084800343"></p><h4 id="消费模式" tabindex="-1"><a class="header-anchor" href="#消费模式"><span>消费模式：</span></a></h4><ul><li>点对点：所有的<code>consumer</code>位于同一个<code>consumer group</code></li><li>发布订阅模式：每个<code>consumer</code>都有自己唯一的<code>consumer group</code></li></ul><p><img src="'+t+`" alt="image-20210531084930672"></p><p>说明：由两个<code>broker</code>组成的kafka集群，某个<code>topic</code>共有4个<code>partition</code>,共有两个<code>consumer group</code>去消费，<code>consumer group 1</code>有两个<code>consumer </code>,<code>consumer group 2</code> 有5个<code>consumer </code></p><blockquote><p>注意：<code>consumer group</code> 中如果<code>consumer </code>的数量 <code>大于</code>分区<code>partition</code>的数量，则会存在<code>consumer </code>消费不到数据的情况，不过多出来的可以用作<code>容灾备份</code></p></blockquote><h4 id="消费顺序" tabindex="-1"><a class="header-anchor" href="#消费顺序"><span>消费顺序：</span></a></h4><p>Kafka只在<code>partition</code>的范围内保证消费的局部顺序性，不能再同一个<code>topic</code>的多个<code>partition</code>中保证总的消费顺序性，</p><blockquote><p>如果非要保证总体上的顺序消费，可以将<code>topic</code>的<code>partition</code>数量设置为1，将<code>consumer group</code>中的<code>consumer </code>数量也设置为1</p></blockquote><h4 id="消费者客户端" tabindex="-1"><a class="header-anchor" href="#消费者客户端"><span>消费者客户端</span></a></h4><h5 id="必要的参数配置" tabindex="-1"><a class="header-anchor" href="#必要的参数配置"><span>必要的参数配置：</span></a></h5><blockquote><p><code>org.apache.kafka.clients.consumer.ConsumerConfig</code></p></blockquote><ul><li><code>bootstrap.servers</code>：host1:port1,host2:port2</li><li><code>group.id</code>：消费组</li><li><code>key.deserializer</code>：</li><li><code>value.deserializer</code>：</li></ul><h5 id="订阅主题与分区" tabindex="-1"><a class="header-anchor" href="#订阅主题与分区"><span>订阅主题与分区</span></a></h5><blockquote><p>Tips：同一种订阅模式重复订阅会覆盖，不同模式会报错</p></blockquote><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// SubscriptionType.AUTO_TOPICS</span></span>
<span class="line"><span class="token comment">// 指定topic</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> topics<span class="token punctuation">,</span> <span class="token class-name">ConsumerRebalanceListener</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> topics<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// SubscriptionType.AUTO_PATTERN</span></span>
<span class="line"><span class="token comment">// 正则匹配topicName</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token class-name">Pattern</span> pattern<span class="token punctuation">,</span> <span class="token class-name">ConsumerRebalanceListener</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token class-name">Pattern</span> pattern<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// SubscriptionType.USER_ASSIGNED</span></span>
<span class="line"><span class="token comment">// 指定topic + 分区</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">assign</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TopicPartition</span><span class="token punctuation">&gt;</span></span> partitions<span class="token punctuation">)</span> </span>
<span class="line"></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 再均衡监听器</span></span>
<span class="line">  consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token constant">TOPIC_NAME</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ConsumerRebalanceListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token annotation punctuation">@Override</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onPartitionsRevoked</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TopicPartition</span><span class="token punctuation">&gt;</span></span> partitions<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">// partitions 再均衡之前分配的分区信息</span></span>
<span class="line">      <span class="token comment">// 可以做位移提交操作</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Override</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onPartitionsAssigned</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TopicPartition</span><span class="token punctuation">&gt;</span></span> partitions<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">// 再均衡之后，分配到的分区信息</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="反序列化" tabindex="-1"><a class="header-anchor" href="#反序列化"><span>反序列化</span></a></h5><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Deserializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Closeable</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">&gt;</span></span> configs<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isKey<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">T</span> <span class="token function">deserialize</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">default</span> <span class="token class-name">T</span> <span class="token function">deserialize</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">,</span> <span class="token class-name">Headers</span> headers<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Override</span></span>
<span class="line">    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 默认的 字符串反序列化实现</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringDeserializer</span> <span class="token keyword">implements</span> <span class="token class-name">Deserializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">String</span> encoding <span class="token operator">=</span> <span class="token string">&quot;UTF8&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// .....</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Override</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">deserialize</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></span>
<span class="line">                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">else</span></span>
<span class="line">                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> encoding<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnsupportedEncodingException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SerializationException</span><span class="token punctuation">(</span><span class="token string">&quot;Error when deserializing byte[] to string due to unsupported encoding &quot;</span> <span class="token operator">+</span> encoding<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token comment">// ....</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="位移提交" tabindex="-1"><a class="header-anchor" href="#位移提交"><span>位移提交</span></a></h5><blockquote><p>offset：Topic每个分区下每条消息唯一的<code>offset</code>值</p><p>存储：kafka 提供了一个内部 topic <code>_consumer_offsets</code> 来存储所有<code>consumerGroup</code>的offset信息，默认50个分区，可以通过<code>offsets.topic.num.partitions</code>指定</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"><span class="token comment"># 存储的分区计算：</span></span>
<span class="line">Math.abs<span class="token punctuation">(</span><span class="token string">&quot;consumerGropuID&quot;</span>.hashCode<span class="token punctuation">(</span><span class="token punctuation">))</span> % <span class="token number">50</span></span>
<span class="line"><span class="token comment"># 查看提交记录</span></span>
<span class="line">bin/kafka-simple-consumer-shell.sh <span class="token parameter variable">--topic</span> __consumer_offsets <span class="token parameter variable">--partition</span> <span class="token number">49</span> --broker-list <span class="token number">172.20</span>.39.2:9092 <span class="token parameter variable">--formatter</span> <span class="token string">&quot;kafka.coordinator.GroupMetadataManager\\<span class="token variable">$OffsetsMessageFormatter</span>&quot;</span> </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+c+'" alt="image-20210805192328049"></p><p>消费者消费完消息后，进行消息的提交,提交的 <code>offset</code> 值为当前消费的<code>最大offset +1 </code></p><p><img src="'+l+`" alt="image-20210806082425949"></p></blockquote><h6 id="offset提交流程" tabindex="-1"><a class="header-anchor" href="#offset提交流程"><span><code>offset</code>提交流程：</span></a></h6><ul><li>consumer执行poll时，先请求服务端，获取当前（consummerGroup、topic、partition）需要消费的<code>offset</code>值，且本地缓存<code>Map&lt;TopicPartition, TopicPartitionState&gt; </code></li><li>当<code>poll</code>拉取到消息后，更新本地缓存的<code>TopicPartitionState 中的 position</code>值为最后一条record 的 offset值</li><li>自动提交(默认)： <ul><li>每隔 5s(可配置)，将拉取到的各个分区的最大位移值进行提交，且为异步提交方式 <ul><li>消息丢失：位移已经提交，消费消费出现异常</li><li>消息重复消费：有五秒延时，已消费完成部分数据，但未提交时，出现异常</li></ul></li></ul></li><li>手动提交： <ul><li>显示执行：consumer.commitSync(); 或者 consumer.commitAsync();</li><li>consumer.commitSync() <ul><li>会阻塞，性能略差，如果程序消费至一半，出现异常，没有提交位移，则会发生重复消费的问题</li></ul></li><li>consumer.commitAsync() <ul><li>异步提交方式，可以提供callback参数，对提交结果做相应处理，但是如果真的提交失败了，依然会存在一些问题：比如同时两个异步提交的请求，第一个失败了，第二个成功了，代码中对失败的处理为重试，第一个失败后重试又成功了，则会覆盖第二次的提交offse，所以并没有完美的解决方案；更何况一般情况下位移提交也不会失败。</li></ul></li></ul></li></ul><h6 id="配置参数" tabindex="-1"><a class="header-anchor" href="#配置参数"><span>配置参数：</span></a></h6><ul><li><p><code>enable.auto.commit</code>: 是否自动提交 true/false</p></li><li><p><code>auto.commit.interval.ms</code>: 为自动提交时，自动提交的时间间隔</p></li></ul><h4 id="指定位移消费" tabindex="-1"><a class="header-anchor" href="#指定位移消费"><span>指定位移消费</span></a></h4><blockquote><p><code>auto.offset.reset</code>:</p><ul><li>latest（默认）:只消费自己启动之后发送到主题的消息</li><li>earliest：第一次从头开始消费，以后按照消费消费组offset记录继续消费，这个需要区别于consumer.seekToBeginning(每次都从头开始消费)</li><li>none：当前消费组没有消费位移记录时，抛出异常<code>NoOffsetForPartitionException</code></li></ul></blockquote><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// api 优先于 auto.offset.reset</span></span>
<span class="line"><span class="token comment">// 从头开始消费</span></span>
<span class="line">consumer<span class="token punctuation">.</span><span class="token function">seekToBeginning</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TopicPartition</span><span class="token punctuation">(</span><span class="token constant">TOPIC_NAME</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 指定位移消费</span></span>
<span class="line">consumer<span class="token punctuation">.</span><span class="token function">seek</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TopicPartition</span><span class="token punctuation">(</span><span class="token constant">TOPIC_NAME</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 0.11.x 版本增加：从指定时间点开始消费</span></span>
<span class="line"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PartitionInfo</span><span class="token punctuation">&gt;</span></span> topicPartitions <span class="token operator">=</span> consumer<span class="token punctuation">.</span><span class="token function">partitionsFor</span><span class="token punctuation">(</span><span class="token constant">TOPIC_NAME</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// 从1小时前开始消费</span></span>
<span class="line"><span class="token keyword">long</span> fetchDataTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TopicPartition</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">PartitionInfo</span> par <span class="token operator">:</span> topicPartitions<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TopicPartition</span><span class="token punctuation">(</span>topicName<span class="token punctuation">,</span> par<span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fetchDataTime<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token comment">// 根据时间拿到 offset值</span></span>
<span class="line"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TopicPartition</span><span class="token punctuation">,</span> <span class="token class-name">OffsetAndTimestamp</span><span class="token punctuation">&gt;</span></span> parMap <span class="token operator">=</span> consumer<span class="token punctuation">.</span><span class="token function">offsetsForTimes</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TopicPartition</span><span class="token punctuation">,</span> <span class="token class-name">OffsetAndTimestamp</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> parMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token class-name">TopicPartition</span> key <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token class-name">OffsetAndTimestamp</span> value <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> value <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token class-name">Long</span> offset <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">offset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;partition-&quot;</span> <span class="token operator">+</span> key<span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;|offset-&quot;</span> <span class="token operator">+</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">//根据消费里的timestamp确定offset</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    consumer<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// 指定位移消费</span></span>
<span class="line">    consumer<span class="token punctuation">.</span><span class="token function">seek</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="rebalance机制" tabindex="-1"><a class="header-anchor" href="#rebalance机制"><span>Rebalance机制</span></a></h4><blockquote><p>指的是当消费组中的消费者数量发生变化或者消费的topic分区数发生变化时，kafka重新分配消费者消费分区的关系；比如：消费组中某个消费者挂掉了，此时会将分配给它的分区交给其他消费者，如果它又重启了，则又会把一些分区分配给它</p></blockquote><h5 id="触发rebalance机制" tabindex="-1"><a class="header-anchor" href="#触发rebalance机制"><span><strong>触发<code>Rebalance</code>机制：</strong></span></a></h5><ul><li>有新的消费者加入消费组</li><li>有消费者宕机下线，也可能并非真正的下线，如遇到网络延迟情况，长时间未和<code>GroupCoordinator</code>发送心跳，<code>GroupCoordinator</code>会认为消费者下线</li><li>有消费者主动退出消费组,比如调用<code>unsubscribe()</code></li><li>消费组对应的<code>GroupCoordinator</code>节点发生变化</li><li>订阅的主题或主题的分区发生变化</li></ul><p><strong>注意</strong>：</p><ul><li>如果消费者通过<code>assign</code> Api指定分区消费，则此消费者不会<code>Rebalance</code></li><li><code>Rebalance</code>过程中，消费者无法从kafka消费消息，所以应当避免高峰期<code>Rebalance</code>发生</li></ul><h5 id="rebalance-策略" tabindex="-1"><a class="header-anchor" href="#rebalance-策略"><span><strong>Rebalance 策略：</strong></span></a></h5><p>假设当前10个分区(0~9) , 消费组下3个 consumer</p><ul><li><strong>range</strong>(默认): m = 分区数 % 消费者数 = 1；n = 分区数 / 消费者数 = 3，则前 m 个消费者 消费分区 n+1 个，剩余消费者消费分区n <ul><li>分区 0~3 分配给consumer1；4~6 分配给consumer2；7~9分配给consumer3</li></ul></li><li><strong>round-robin</strong>：轮询分配方式 <ul><li>0、3、6、9 分配给consumer1；1、4、7分配给consumer2；2、5、8分配给consumer3</li></ul></li><li><strong>sticky</strong>：0.11.x版本增加，类似黏性的<code>range</code><ul><li>原则： <ul><li>分配尽可能均匀</li><li>分配尽可能与上次分配保持相同</li></ul></li><li>如：分区 0~3 分配给consumer1；4~6 分配给consumer2；7~9分配给consumer3，当 consumer3 挂掉后 <ul><li><code>rang</code>：0~4 分配给consumer1，5~9 分配给consumer2</li><li><code>sticky</code>：0~3 、7 分配给 consumer1，4~6、8、9 分配给 consumer2（尽量保持和上次分配相同）</li></ul></li></ul></li></ul><h5 id="rebalance-过程" tabindex="-1"><a class="header-anchor" href="#rebalance-过程"><span><strong>Rebalance 过程</strong>：</span></a></h5><h6 id="组件" tabindex="-1"><a class="header-anchor" href="#组件"><span>组件：</span></a></h6><p><strong>组协调器<code>GroupCoordinator</code></strong>：每个consumer group都会选择一个broker作为自己的组协调器coordinator，负责监控这个消费组里的所有消费者的心跳，以及判断是否宕机，然后开启消费者rebalance</p><p><strong>消费者协调器<code>ConsumerCoordinator</code></strong>：每个consumer都会构造自己的协调器，与<code>GroupCoordinator</code>进行交互，形成消费者和服务端之间的桥梁</p><blockquote><p>消费者协调器主要负责如下工作：</p><ul><li><p>更新消费者缓存的MetaData</p></li><li><p>查找组协调器</p></li><li><p>向组协调器申请加入组</p></li><li><p>请求离开消费组</p></li><li><p>向组协调器提交偏移量</p></li><li><p>通过心跳，保持组协调器的连接感知。</p></li><li><p>被组协调器选为leader的消费者的协调器，负责消费者分区分配。分配结果发送给组协调器。</p></li><li><p>非leader的消费者，通过消费者协调器和组协调器同步分配结果。</p></li></ul></blockquote><h6 id="过程" tabindex="-1"><a class="header-anchor" href="#过程"><span>过程</span></a></h6><p><img src="`+i+`" alt="image-20220127114954375"></p><ol><li><p>找到<code>GroupCoordinator</code></p><ul><li><p>向集群中的某个节点发送<code>FindCoordinatorRequest</code></p><ul><li>非随机节点，是之前提到过的<code>leastLoadedNode</code></li></ul></li><li><p>当前消费组<code>offset</code>所要提交至<code>_consumer_offset</code>topic的哪个分区，则此分区的 <code>leader</code>节点broker，就是当前消费组的<code>GroupCoordinator</code></p></li></ul></li><li><p>加入消费组<code>JOIN Group</code> &amp; 分区方案制定</p><ul><li>在成功找到消费组所对应的 <code>GroupCoordinator</code> 之后就进入加入消费组的阶段，在此阶段的消费者会向 <code>GroupCoordinator</code> 发送 <code>JoinGroupRequest</code> 请求，并处理响应。然后GroupCoordinator 从一个consumer group中选择第一个加入group的consumer作为<code>leader</code>，把consumer group情况发送给这个leader，接着这个leader会负责制定分区方案。 <ul><li>如果消费组内的<code>leader</code>由于某些情况退出了消费组，则在消费组内的消费者列表中，随机选择一个作为<code>leader</code></li></ul></li><li>做一些其他事情 <ul><li>如果为自动提交，则在发送<code>JoinGroupRequest</code> 之前，需要同步提交<code>offset</code></li><li>如果配置了<code>ConsumerRebalanceListener</code>,需要调用<code>onPartitionsRevoked</code></li></ul></li></ul></li><li><p>同步分区数据<code>SYNC_GROUP</code></p><ul><li>consumer leader通过给<code>GroupCoordinator</code>发送 <code>SyncGroupRequest</code>，同时将分区方案，发送至 <code>GropCoordinator</code></li><li>非 leader consumer 也向<code> GroupCoordinator</code> 发送 <code>SyncGroupRequest</code></li><li><code>SyncGroupResponseHandler</code>响应中，返回 分区方案，并更新本地分区方案数据</li><li>再根据指定分区的leader broker进行网络连接以及消息消费。</li><li>如果配置了<code>ConsumerRebalanceListener</code>,需要调用<code>onPartitionsAssigned</code></li></ul></li></ol><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// 客户端、服务端 交互关键类</span></span>
<span class="line"><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>common<span class="token punctuation">.</span>protocol<span class="token punctuation">.</span></span>ApiKeys</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 消费者拉取过程</span></span>
<span class="line">		<span class="token comment">// 循环 确保协调器准备好了 GroupCoordinator</span></span>
<span class="line">    <span class="token function">poll</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>common<span class="token punctuation">.</span>utils<span class="token punctuation">.</span></span>Timer</span><span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token comment">// 更新topic、partition 信息</span></span>
<span class="line">        <span class="token function">updateAssignmentMetadataIfNeeded</span><span class="token punctuation">(</span>timer<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            coordinator<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>timer<span class="token punctuation">,</span> waitForJoinGroup<span class="token punctuation">)</span></span>
<span class="line">                <span class="token comment">// 查找组协调器，设置 AbstractCoordinator.this.coordinator value</span></span>
<span class="line">                <span class="token function">ensureCoordinatorReady</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span></span>
<span class="line">                    <span class="token function">lookupCoordinator</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">                        <span class="token comment">// 构造FindCoordinatorRequest,放到缓存中</span></span>
<span class="line">                        unsent<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> clientRequest<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                    <span class="token comment">// 拉取 unset 中的数据，发送请求</span></span>
<span class="line">                    client<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>future<span class="token punctuation">,</span> timer<span class="token punctuation">)</span></span>
<span class="line">                <span class="token comment">// 判断是否需要 join group</span></span>
<span class="line">                <span class="token function">rejoinNeededOrPending</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">                <span class="token comment">// 加入组</span></span>
<span class="line">                <span class="token function">ensureActiveGroup</span><span class="token punctuation">(</span>waitForJoinGroup <span class="token operator">?</span> timer <span class="token operator">:</span> time<span class="token punctuation">.</span><span class="token function">timer</span><span class="token punctuation">(</span><span class="token number">0L</span><span class="token punctuation">)</span></span>
<span class="line">                    <span class="token comment">// 启动 心跳线程</span></span>
<span class="line">                    <span class="token function">startHeartbeatThreadIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">                    <span class="token comment">// 加入消费组</span></span>
<span class="line">                    <span class="token function">joinGroupIfNeeded</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span></span>
<span class="line">                        <span class="token comment">// 分区变化前的方法调用</span></span>
<span class="line">                        <span class="token function">onJoinPrepare</span><span class="token punctuation">(</span>generation<span class="token punctuation">.</span>generationId<span class="token punctuation">,</span> generation<span class="token punctuation">.</span>memberId<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                        <span class="token comment">// 构造加入请求</span></span>
<span class="line">                        <span class="token function">initiateJoinGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">                        <span class="token comment">// 发送加入请求，并等待加入完成</span></span>
<span class="line">                        client<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>future<span class="token punctuation">,</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                            <span class="token comment">// 加入成功之后的回调</span></span>
<span class="line">                            <span class="token class-name">JoinGroupResponseHandler</span>#handle</span>
<span class="line">                                <span class="token comment">// 如果当前节点为 leader，进行分区 和 consumer 绑定划分</span></span>
<span class="line">                                <span class="token comment">// 非leader节点，也发送 syncGroupRequest</span></span>
<span class="line">                                <span class="token function">onJoinLeader</span><span class="token punctuation">(</span>joinResponse<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span></span>
<span class="line">                                    <span class="token comment">// 完成分区分配后，发送 SyncGroup,回调 SyncGroupResponseHandler</span></span>
<span class="line">                                    client<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>coordinator<span class="token punctuation">,</span> requestBuilder<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compose</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SyncGroupResponseHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">                                    <span class="token comment">// 同步回调方法</span></span>
<span class="line">                                    <span class="token class-name">SyncGroupResponseHandler</span>#handle</span>
<span class="line">                                        <span class="token comment">// 将分区分配信息，赋值给 future 对象，此future 对象就是 joinGroup时，生成的</span></span>
<span class="line">                                        future<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span><span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span>syncResponse<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">assignment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">                        <span class="token comment">// 加入完成方法</span></span>
<span class="line">                        <span class="token function">onJoinComplete</span><span class="token punctuation">(</span></span>
<span class="line">                            <span class="token comment">// 更新本地消费的topic分区信息</span></span>
<span class="line">                            subscriptions<span class="token punctuation">.</span><span class="token function">assignFromSubscribed</span><span class="token punctuation">(</span>assignedPartitions<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                            <span class="token comment">// 调用分区变更后的方法</span></span>
<span class="line">                            firstException<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span></span>
<span class="line">        <span class="token comment">// 更新本地 offset                    </span></span>
<span class="line">        <span class="token function">updateFetchPositions</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>                        </span>
<span class="line">				<span class="token comment">// 拉取数据</span></span>
<span class="line">        <span class="token function">pollForFetches</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span></span>
<span class="line">            <span class="token comment">// 请求真正的业务数据</span></span>
<span class="line">            fetcher<span class="token punctuation">.</span><span class="token function">sendFetches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                <span class="token comment">// 按每个分区循环发送数据请求，因为分区不同，leader不同，请求的节点不同</span></span>
<span class="line">                <span class="token function">prepareFetchRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token comment">// 接收响应数据,</span></span>
<span class="line">            client<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span></span>
<span class="line">            <span class="token comment">// 按最大数量，拉取缓存中的数据</span></span>
<span class="line">            fetcher<span class="token punctuation">.</span><span class="token function">fetchedRecords</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>旧版客户端存在问题</strong>：</p><p>在zk中维护的节点信息：</p><ul><li>消费组：<code>/consumers/&lt;group&gt;/ids</code></li><li>broker：<code>brokers/ids/&lt;id&gt;</code></li><li>Topic：<code>/brokers/topics/&lt;topic&gt;</code></li><li>partition：<code>/brokers/topics/&lt;topic&gt;/partitions/&lt;partition&gt;/state</code></li><li>......</li></ul><p>因为zk中很多节点信息发生变化时，都会触发再均衡操作，所以每个消费者都需要在每条相关路径注册<code>Watcher</code>,这种严重依赖zk集群的做法有两个严重的问题：</p><ul><li><strong>羊群效应</strong>：指的是zk中一个被监听的节点发生变化，大量的<code>Watcher</code>通知被发送至客户端，导致其他操作将被延迟，也可能发生类似死锁的情况</li><li><strong>脑裂问题</strong>：消费者进行再均衡操作时每个消费者都与zk通信，以判断消费者或broker变化的情况，由于zk自身的特性，可能导致在同一时刻各个消 费者获取的状态不一致，这样会导致异常问题发生。</li></ul><h4 id="多线程实现" tabindex="-1"><a class="header-anchor" href="#多线程实现"><span>多线程实现</span></a></h4><ul><li><code>producer</code> 是线程安全的，多个线程可以同时一个<code>producer</code>实例使用发送信息</li><li><code>consumer</code> 非线程安全 <ul><li><code>acquireAndEnsureOpen();</code>判断如果有多个线程在操作，会抛出异常</li></ul></li><li>多线程实现方式： <ul><li>每个线程，实例化一个 <code>KafkaConsumer</code>对象，就相当于启动了 多个<code>consumer</code>节点</li><li>一个<code>KafkaConsumer</code>对象去<code>poll</code>消息，处理消息使用多线程 <ul><li>这样方式下，因为多线程之间无序处理， <code>手动提交offset</code>会变得比较复杂，最好使用<code>自动提交offset</code></li></ul></li></ul></li></ul><h4 id="重要的消费者参数" tabindex="-1"><a class="header-anchor" href="#重要的消费者参数"><span>重要的消费者参数</span></a></h4><ul><li><code>fetch.min.bytes</code> 和 <code>fetch.max.wait.ms</code>：调用<code>poll()</code>方法，需要拉取到的最小数据量，<code>fetch.min.bytes(默认1B)</code>；当kafka返回给consumer的数据量小于此值，则会继续等待，直到数据量大于等于此配置，或超过 <code>fetch.max.wait.ms（默认500）</code>配置的时间；适当调大此参数可以提高一定的吞吐量，但是也会有一定延迟</li><li><code>enable.auto.commit</code>：是否自动提交，默认<code>是</code></li><li><code>auto.commit.interval.ms</code>：自动提交时，时间间隔,默认<code>5000</code></li><li><code>auto.offset.reset</code>: <ul><li>latest（默认）:只消费自己启动之后发送到主题的消息</li><li>earliest：第一次从头开始消费，以后按照消费offset记录继续消费，这个需要区别于consumer.seekToBeginning(每次都从头开始消费)</li><li>none：当前消费组没有消费位移记录时，抛出异常<code>NoOffsetForPartitionException</code></li></ul></li><li><code>heartbeat.interval.ms</code>: consumer 和 group coordinator 心跳的间隔时间，若发生了 rebalance，consumer 收到的响应中会包含REBALANCE_IN_PROGRESS. <ul><li>必须小于<code>session.timeout.ms</code></li><li>默认<code>3000</code></li></ul></li><li><code>session.timeout.ms</code>: 多长时间未感知到心跳，则认为<code>consumer</code>挂掉了，会将其踢出消费组 <ul><li>0.10.1 版本之前是 <code>30000</code></li><li>0.10.1 版本之后是 <code>10000</code></li></ul></li><li><code>max.poll.interval.ms</code>：0.10.1版本后才有，在这之前<code>发送心跳包</code>和<code>消息处理逻辑</code>这2个过程是耦合在一起的，试想：如果一条消息处理时长要5min，而session.timeout.ms=3000ms，那么等 kafka consumer处理完消息，因为只有一个线程，在消息处理过程中就无法向group coordinator发送心跳包，超过3000ms未发送心跳包，group coordinator就将该consumer移出group了；而将二者分开，一个线程负责执行消息处理逻辑，一个线程负责发送心跳包，那么：就算一条消息需要处理5min，只要heartbeat线程在session.timeout.ms 向 group coordinator发送了心跳包，那consumer可以继续处理消息，而不用担心被移出group了，所以 0.10.1 版本后，<code>session.timeout.ms</code> 默认值发生变化</li><li><code>max.poll.records</code>：每次<code>poll</code>最大拉取条数，默认 <code>500</code></li></ul><h4 id="问题" tabindex="-1"><a class="header-anchor" href="#问题"><span>问题</span></a></h4><ul><li>内部topic默认几个副本 <ul><li>跟随 server端配置的默认副本数 <code>default.replication.factor</code>,默认为 1</li></ul></li></ul>`,59)]))}const m=s(u,[["render",r],["__file","kafka_consumer.html.vue"]]),v=JSON.parse('{"path":"/blogs/jishu/kakfa/kafka_consumer.html","title":"Kafka-Consumer","lang":"en-US","frontmatter":{"title":"Kafka-Consumer","date":"2021-06-02T00:00:00.000Z","author":"shuiMu","categories":["技术"],"tags":["kafka"]},"headers":[{"level":3,"title":"consumer","slug":"consumer","link":"#consumer","children":[]}],"git":{"createdTime":1729235013000,"updatedTime":1729235013000,"contributors":[{"name":"peng.li","email":"lip.app@qq.com","commits":1}]},"filePathRelative":"blogs/技术/kakfa/kafka_consumer.md"}');export{m as comp,v as data};
