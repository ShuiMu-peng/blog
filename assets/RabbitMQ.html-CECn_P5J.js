import{_ as t,c as l,e as a,o as n}from"./app-CmsP-zbh.js";const s="/blog/rabbitMQ.assets/image-20241025155910047.png",i="/blog/rabbitMQ.assets/image-20241025160053800.png",o="/blog/rabbitMQ.assets/image-20241025160444633.png",c="/blog/rabbitMQ.assets/image-20241025160456926.png",d="/blog/rabbitMQ.assets/image-20241025160509795.png",r="/blog/rabbitMQ.assets/image-20241025160524082.png",p="/blog/rabbitMQ.assets/image-20241025160544256.png",u="/blog/rabbitMQ.assets/image-20241025160718447.png",h="/blog/rabbitMQ.assets/image-20241025160829682.png",g={};function b(m,e){return n(),l("div",null,e[0]||(e[0]=[a('<h2 id="rabbitmq-vs-kafka-vs-rocketmq" tabindex="-1"><a class="header-anchor" href="#rabbitmq-vs-kafka-vs-rocketmq"><span>RabbitMQ VS kafka VS RocketMQ</span></a></h2><table><thead><tr><th style="text-align:left;">RabbitMQ</th><th style="text-align:left;">Kafka</th><th style="text-align:left;">RocketMQ</th><th></th></tr></thead><tbody><tr><td style="text-align:left;">协议</td><td style="text-align:left;">AMQP https://www.rabbitmq.com/tutorials/amqp-concepts.html</td><td style="text-align:left;">一套自行设计的基于 TCP 的二进制协议</td><td>自己定义的一 套(社区提供 JMS)https://www.jianshu.com/p/d2e3fd77c4f4</td></tr><tr><td style="text-align:left;">消息可靠性</td><td style="text-align:left;">通过配置不丢数据</td><td style="text-align:left;">通过配置不丢数据</td><td>通过配置不丢数据</td></tr><tr><td style="text-align:left;">延迟</td><td style="text-align:left;">微秒</td><td style="text-align:left;">毫秒</td><td>毫秒</td></tr><tr><td style="text-align:left;">吞吐量</td><td style="text-align:left;">万级 QPS</td><td style="text-align:left;">百万级 QPS</td><td>十万级 QPS</td></tr><tr><td style="text-align:left;">可用性</td><td style="text-align:left;">高，但不支持 动态扩容</td><td style="text-align:left;">非常高</td><td>非常高</td></tr><tr><td style="text-align:left;">消费模型</td><td style="text-align:left;">pull/push</td><td style="text-align:left;">pull</td><td>pull/push</td></tr><tr><td style="text-align:left;">语言</td><td style="text-align:left;">erlang</td><td style="text-align:left;">scala</td><td>java</td></tr><tr><td style="text-align:left;">适用用场景</td><td style="text-align:left;">数据量不是很大，对消息的实时性、要求很高</td><td style="text-align:left;">日志采集、适合产生大量数据的互联网服务的数据收集业务等场景</td><td>几乎全场景</td></tr><tr><td style="text-align:left;">缺点</td><td style="text-align:left;">1、集群 不支持动态扩展 2、消息吞吐能力有限 3、消息堆积时，性能会明显 降低。 4、erlang语言开发，出现问题只能依赖社区，不利于二次开发维护</td><td style="text-align:left;">1、Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长 2、仅支持的简单的消费模式</td><td>1、使用者较少，生态不够 完善 2、消息堆积与吞吐量 上与 kafka 还是有差距。 3、客户端支持 java及c++，c++不成熟</td></tr></tbody></table><h2 id="amqp协议" tabindex="-1"><a class="header-anchor" href="#amqp协议"><span>AMQP协议</span></a></h2><blockquote><p>（Advanced Message Queuing Protocol，高级消息队列协议）</p></blockquote><h3 id="工作过程" tabindex="-1"><a class="header-anchor" href="#工作过程"><span><strong>工作过程</strong>：</span></a></h3><p>消息（message）被发布者（publisher）发送给交换机（exchange），交换机常常被比喻成邮局或者邮箱。然后交换机将收到的消息根据路由规则分发给绑定的队列（queue）。最后AMQP代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取</p><p><img src="'+s+'" alt="image-20241025155910047"></p><h3 id="组件介绍" tabindex="-1"><a class="header-anchor" href="#组件介绍"><span>组件介绍</span></a></h3><ul><li><strong>Publisher</strong>：消息发布者</li><li><strong>Exchanage</strong>：交换机，消息代理服务器，通过一定的路由规则，将消息发送至队列中,存储有不同RoutingKey到queue的规则 <ul><li><strong>默认交换机</strong>（default exchange）：举个栗子：当你声明了一个名为search-indexing-online的队列，AMQP代理会自动将其绑定到默认交换机上，绑定（binding）的路由键名称也是为search-indexing-online。因此，当携带着名为search-indexing-online的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为search-indexing-online的队列中， <ul><li>Publisher 发送消息时，指定 queue</li></ul></li><li><strong>直连交换机</strong>（direct exchange）：Exchange和queue之间通过RoutingKey来建立binding关系，发送消息时，指定RoutingKey发送到Exchange，Exchange通过RoutingKey转发到相应的queue； <ul><li>直连交换机经常用来循环分发任务给多个工作者，这样做：消息的负载均衡是发生在消费者之间，并非队列之间</li><li>Publisher 发送消息时，指定 Exchange、RoutingKey</li></ul></li><li><strong>扇形交换机</strong>（funout exchange）：发布订阅模式，Exchange 和 queue之间直接 binding <ul><li>Publisher 发送消息时，定Exchange，不用指定RoutingKey,Exchange 会将消息转发给所有绑定的queue</li></ul></li><li><strong>主题交换机</strong>（topic exchange）：类似于直连交换机，RoutingKey支持规则匹配 <ul><li>Publisher 发送消息时，指定 Exchange、RoutingKey</li></ul></li><li><strong>头交换机</strong>（headers exchange）：类似于直连交换机，不同点是direct exchange是通过 RoutingKey绑定关系，headers exchange 可以通过多个属性来绑定关系 <ul><li>Publisher 发送消息时，指定 Exchange、Map(多个属性)</li></ul></li></ul></li><li><strong>Queue</strong>：存储消息</li><li><strong>Binding</strong>：是exchange将消息路由给queue所遵循的规则，可结合exchange的几种类型，Binding信息被保存到Exchange中的查询表中，用于message的分发依据</li><li><strong>Consumer</strong>：消息消费者 <ul><li>消息确认机制 <ul><li>自动确认：消费端收到消息，就会自动确认</li><li>手动确认：显式提交确认</li></ul></li></ul></li><li><strong>Virtual host</strong>：多租户概念，类似mysql中的数据库，之间相互隔离</li><li><strong>Connection</strong>：publisher／consumer 和 broker 之间的 TCP 连接</li><li><strong>Channel</strong>： 如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的 channel 进行通讯，AMQP method 包含了channel id 帮助客户端和message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销</li></ul><h2 id="基础架构" tabindex="-1"><a class="header-anchor" href="#基础架构"><span>基础架构</span></a></h2><p><img src="'+i+'" alt="image-20241025160053800"></p><h3 id="常用模式" tabindex="-1"><a class="header-anchor" href="#常用模式"><span>常用模式</span></a></h3><blockquote><p>官网地址: https://www.rabbitmq.com/getstarted.html</p><p>主要介绍下面五种</p></blockquote><h4 id="simple" tabindex="-1"><a class="header-anchor" href="#simple"><span>Simple</span></a></h4><blockquote><p><img src="'+o+'" alt="image-20241025160444633"></p><p>不用配置<code>Exchange</code>，会有默认的<code>Exchange</code>，生产者定向发送至队列，消费者从队列中消费</p></blockquote><h4 id="work-queues" tabindex="-1"><a class="header-anchor" href="#work-queues"><span>Work queues</span></a></h4><blockquote><p><img src="'+c+'" alt="image-20241025160456926"></p><p>工作队列模式</p><p>类似<code>Simple</code>模式，多消费者 消费。</p><p>注意: 消息仅能被一个消费者消费,消息的负载均衡是发生在消费者之间，并非队列之间</p><p>不同与 kafka 中，partition 被多个消费者消费时，每个消费者有着自己的offset，也就是说每条消息可以被多个消费者所消费</p></blockquote><h4 id="publish-subscribe" tabindex="-1"><a class="header-anchor" href="#publish-subscribe"><span>Publish/Subscribe</span></a></h4><blockquote><p><img src="'+d+'" alt="image-20241025160509795"></p><p>广播模式</p><p><code>Exchange</code>配置为<code>fanout</code>，<code>Exchange</code> 绑定队列，生产者发送消息时，指定<code>Exchange</code>，消息将会发送到该交换机绑定的所有队列中，被监听队列的消费者消费</p></blockquote><h4 id="routing" tabindex="-1"><a class="header-anchor" href="#routing"><span>Routing</span></a></h4><blockquote><p><img src="'+r+'" alt="image-20241025160524082"></p><p>路由模式</p><p><code>Exchange</code>配置为<code>direct</code></p><p><code>Exchange</code>和<code>queue</code>之间通过<code>RoutingKey</code>来建立关系，发送消息时，指定<code>RoutingKey</code>发送到<code>Exchange</code>，<code>Exchange</code>通过<code>RoutingKey</code>转发到相应的<code>queue</code>，</p><p>注意：<code>RoutingKey</code>精确匹配</p></blockquote><h4 id="topics" tabindex="-1"><a class="header-anchor" href="#topics"><span>Topics</span></a></h4><blockquote><p><img src="'+p+'" alt="image-20241025160544256"></p><p>主题模式</p><p><code>Exchange</code>配置为<code>topic</code>，过程类似<code>RoutingKey</code>，不同的是 支持 <code>RoutingKey</code>的模糊匹配 <code>#</code>多个字符；<code>*</code>单个字符</p></blockquote><h2 id="高级特性" tabindex="-1"><a class="header-anchor" href="#高级特性"><span>高级特性</span></a></h2><h3 id="生产者" tabindex="-1"><a class="header-anchor" href="#生产者"><span>生产者：</span></a></h3><blockquote><p>整个消息投递的路径：</p><p><code>producer</code> &gt; <code>exchange</code> &gt; <code>queue</code> &gt; <code>consumer</code></p><ul><li><p>confirm</p><ul><li>消息到达<code>exchange</code>时，进行回调</li></ul></li><li><p>return</p><ul><li>消息从<code>exchange</code> &gt; <code>queue</code>投递<code>失败</code>时，回调</li></ul></li></ul><p>利用这两个回调机制，当消息发送失败时，做一些补偿策略，重试，或者记录下来，人为控制</p></blockquote><h3 id="消费者" tabindex="-1"><a class="header-anchor" href="#消费者"><span>消费者：</span></a></h3><blockquote><p>默认模式为自动签收，表示一旦被consumer接收到，则自动签收，但实际中，可能会出现业务代码执行异常的情况，导致消息没有被真正消费掉(消息丢失)。</p><ul><li>手动签收 <ul><li>通过业务代码的执行状态，进行签收或者拒绝签收控制，拒绝签收后，mq会再次发送消息，也应该设置重试次数，超过阈值后，记录到数据库中，人工调控，防止无限重试</li></ul></li></ul></blockquote><h3 id="消费端限流" tabindex="-1"><a class="header-anchor" href="#消费端限流"><span>消费端限流</span></a></h3><blockquote><p>举个栗子：服务器A、B各启动了一个消费者，500个消息，默认每个消费者会拉取250条缓存到本地，去消费处理，如果A机器效率很高，就会发生A很快处理完成，闲置状态，B一直做工的状态；如果配置<code>prefetch</code>各为5，则每个消费者会预取5条消息，缓存到本地，每处理完成签收一条消息，就会再接收服务端的一条新消息，始终保持本地缓存5条消息的状态，最终达到的效果就是 效率高的机器，处理消息多，充分利用所有机器的性能。</p><p>原理：消费者客户端，本地会有个缓存队列 ，用来存储从服务端拉取的消息，大小就是<code>prefetch</code>，如果没有设置，默认为<code>250</code>,可查看类<code>BlockingQueueConsumer</code>。</p><p>配置注意点：</p><ul><li><p>消费端的确认模式一定为手动确认</p></li><li><p><code>prefetch</code>表示每个消费者端拉取(缓存)的消息数量，循环串行化处理，并非并行处理</p></li><li><p><code>concurrency</code>当前客户端启动的消费者数量。举例：设置为2，表示两个消息并行处理</p></li></ul></blockquote><h3 id="ttl" tabindex="-1"><a class="header-anchor" href="#ttl"><span>TTL</span></a></h3><blockquote><ul><li>TTL 全称 Time To Live（存活时间/过期时间）</li><li>当消息到达存活时间后，还没有被消费，会被自动清除</li><li>RabbitMQ可以对消息设置过期时间，也可以对整个队列（Queue）设置过期时间 <ul><li>如果队列和消息都设置了过期时间，以时间短的为准</li></ul></li></ul></blockquote><h3 id="死信队列" tabindex="-1"><a class="header-anchor" href="#死信队列"><span>死信队列</span></a></h3><blockquote><p>死信队列，英文缩写：DLX 。Dead Letter Exchange（死信交换机），当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是DLX</p><p><img src="'+u+'" alt="image-20241025160718447"></p><p><strong>成为死信队列的条件：</strong></p><ul><li>队列消息长度到达限制</li><li>消费者拒接消费消息，basicNack/basicReject,并且不把消息重新放入原目标队列,requeue=false</li><li>原队列存在消息过期设置，消息到达超时时间未被消费</li></ul></blockquote><h3 id="延时队列" tabindex="-1"><a class="header-anchor" href="#延时队列"><span>延时队列</span></a></h3><blockquote><p>延迟队列，即消息进入队列后不会立即被消费，只有到达指定时间后，才会被消费</p><p>需求：下单后，三十分钟未支付，取消订单，库存回滚</p><p>ttl + 死信队列，达到延时队列的效果，如上图所示。</p></blockquote><h3 id="幂等性保证" tabindex="-1"><a class="header-anchor" href="#幂等性保证"><span>幂等性保证</span></a></h3><blockquote><p>消息保证不丢失，但无法保证重复性消费，所以消费端需要增加幂等性处理</p><p>处理方式很多：业务代码是否消费判断、redis缓存判断、mysql乐观锁等</p></blockquote><h3 id="消息积压" tabindex="-1"><a class="header-anchor" href="#消息积压"><span>消息积压</span></a></h3><blockquote><p>产生原因：</p><ul><li>消费者宕机积压</li><li>消费者消费能力不足积压</li></ul><p>解决方案:</p><ul><li>上线更多的消费者</li><li>将消息先批量取出来,记录数据库或其他地方,再慢慢处理</li></ul></blockquote><h2 id="集群模式" tabindex="-1"><a class="header-anchor" href="#集群模式"><span>集群模式</span></a></h2><blockquote><p>官网地址：https://www.rabbitmq.com/clustering.html</p></blockquote><h3 id="默认集群模式" tabindex="-1"><a class="header-anchor" href="#默认集群模式"><span>默认集群模式</span></a></h3><blockquote><p>RabbitMQ集群仅会同步四种类型的内部元数据：</p><ul><li>队列元数据：队列名称和它的属性</li><li>交换器元数据：交换器名称、类型和属性</li><li>绑定元数据：一张简单的表格展示了如何将消息路由到队列</li><li>vhost元数据：为vhost内的队列、交换器和绑定提供命名空间和安全属性</li></ul><p>无法实现高可用，单节点宕机后，此节点的数据就无法被访问到</p></blockquote><h3 id="镜像集群模式" tabindex="-1"><a class="header-anchor" href="#镜像集群模式"><span>镜像集群模式</span></a></h3><blockquote><p>这种模式，生产级别的高可用模式</p><p>每个节点上都有<code>queue</code>的完整镜像，包含有全部数据</p></blockquote><p>可以通过两种方式配置：</p><ul><li><p>管理界面 <img src="'+h+`" alt="image-20241025160829682"></p></li><li><p>命令行</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"> <span class="token comment">#格式：rabbitmqctl set_policy [-p Vhost] Name Pattern Definition [Priority]</span></span>
<span class="line"> <span class="token comment">#第1种</span></span>
<span class="line"> rabbitmqctl set_policy policy3 <span class="token string">&quot;^&quot;</span> <span class="token string">&#39;{&quot;ha-mode&quot;:&quot;all&quot;}&#39;</span></span>
<span class="line"> <span class="token comment">#第2种</span></span>
<span class="line"> rabbitmqctl set_policy policy2 <span class="token string">&quot;^&quot;</span> <span class="token string">&#39;{&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;}&#39;</span></span>
<span class="line"> <span class="token comment">#第3种</span></span>
<span class="line"> rabbitmqctl set_policy <span class="token parameter variable">-p</span> <span class="token string">&quot;/&quot;</span> policy3 <span class="token string">&quot;^QUEUE&quot;</span> <span class="token string">&#39;{&quot;ha-mode&quot;:&quot;nodes&quot;,&quot;ha-params&quot;:[&quot;rabbit@mq-002&quot;,&quot;rabbit@mq-003&quot;],&quot;ha-sync-mode&quot;:&quot;automatic&quot;}&#39;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>参数说明：</strong></p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line">Virtual host:</span>
<span class="line">Pattern:正则匹配队列 如:^NAME_ 表示 以NAME开头<span class="token punctuation">;</span>^ 表示所有</span>
<span class="line">ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes</span>
<span class="line">  <span class="token comment">#all:表示在集群中所有的节点上进行镜像</span></span>
<span class="line">  <span class="token comment">#exactly:表示在指定个数的节点上进行镜像，节点的个数由ha-params指定</span></span>
<span class="line">  <span class="token comment">#nodes:表示在指定的节点上进行镜像，节点名称通过ha-params指定</span></span>
<span class="line">ha-params:ha-mode模式需要用到的参数</span>
<span class="line">ha-sync-mode:进行队列中消息的同步方式，有效值为 automatic 和 manual</span>
<span class="line">priority:可选参数，policy的优先级，请注意一个事实，镜像配置的pattern 采用的是正则表达式匹配，也就是说会匹配一组。如果配置了多个，则匹配的顺序</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul>`,48)]))}const k=t(g,[["render",b],["__file","RabbitMQ.html.vue"]]),x=JSON.parse('{"path":"/blogs/jishu/mq/RabbitMQ.html","title":"RabbitMq","lang":"en-US","frontmatter":{"title":"RabbitMq","date":"2021-05-11T00:00:00.000Z","author":"shuiMu","categories":["技术"],"tags":["mq","RabbitMq"]},"headers":[{"level":2,"title":"RabbitMQ VS kafka VS RocketMQ","slug":"rabbitmq-vs-kafka-vs-rocketmq","link":"#rabbitmq-vs-kafka-vs-rocketmq","children":[]},{"level":2,"title":"AMQP协议","slug":"amqp协议","link":"#amqp协议","children":[{"level":3,"title":"工作过程：","slug":"工作过程","link":"#工作过程","children":[]},{"level":3,"title":"组件介绍","slug":"组件介绍","link":"#组件介绍","children":[]}]},{"level":2,"title":"基础架构","slug":"基础架构","link":"#基础架构","children":[{"level":3,"title":"常用模式","slug":"常用模式","link":"#常用模式","children":[]}]},{"level":2,"title":"高级特性","slug":"高级特性","link":"#高级特性","children":[{"level":3,"title":"生产者：","slug":"生产者","link":"#生产者","children":[]},{"level":3,"title":"消费者：","slug":"消费者","link":"#消费者","children":[]},{"level":3,"title":"消费端限流","slug":"消费端限流","link":"#消费端限流","children":[]},{"level":3,"title":"TTL","slug":"ttl","link":"#ttl","children":[]},{"level":3,"title":"死信队列","slug":"死信队列","link":"#死信队列","children":[]},{"level":3,"title":"延时队列","slug":"延时队列","link":"#延时队列","children":[]},{"level":3,"title":"幂等性保证","slug":"幂等性保证","link":"#幂等性保证","children":[]},{"level":3,"title":"消息积压","slug":"消息积压","link":"#消息积压","children":[]}]},{"level":2,"title":"集群模式","slug":"集群模式","link":"#集群模式","children":[{"level":3,"title":"默认集群模式","slug":"默认集群模式","link":"#默认集群模式","children":[]},{"level":3,"title":"镜像集群模式","slug":"镜像集群模式","link":"#镜像集群模式","children":[]}]}],"git":{"createdTime":1729844027000,"updatedTime":1729844027000,"contributors":[{"name":"peng.li","email":"lip.app@qq.com","commits":1}]},"filePathRelative":"blogs/技术/mq/RabbitMQ.md"}');export{k as comp,x as data};
