## 查询过程

![image-20230202085158769](/mysql.assets/image-20230202085158769.png)

## 事务

### 概念

##### 事务ACID的特性：

- 原子性：同时成功，同时失败；由undo log 日志来实现
- 一致性：使用事务的最终目的；由其他三个特性以及业务代码正确逻辑来实现
- 持久性：一旦提交了事务，他对数据库的改变就是永久性的，持久性由redo log 日志来实现
- 隔离性：事务并发执行时，内部的操作不能相互干扰，隔离性由Mysql 的各种锁，MVCC机制来实现

##### 事务隔离级别：

- 读未提交
- 读已提交
- 可重复度
  - 幻读：当某个事物中主动根据id 修改数据时，会触发当前读，会拉取最新的数据，则会发现前后select 的数据不同
  - 脏写：update xxx set aa = 100 ，直接赋值的方式导致
- 串行化：串行执行，读的时候增加 读锁（lock in share mode），性能很差

### MVCC

- 快照读：select
- 当前读：insert、update、delete
- 语句级快照：read commit
- 事务级快照：repeatable commit

#### 实现原理：

> undo log  回滚日志，数据版本链条
>
> 1. **每条更改记录，都会增加两个字段：**
>    1. trx_id：事务id
>    2. roll_pointer：回滚的数据指针
> 2. select 读取时，记录当前`read_view` 视图，包括两部分：[当前未提交的所有事务id]，当前已创建的最大事务id
>    1. [100,200],300
>       1. 则小于100的事务id，都已经提交
>    2. 记录min_txid：100，max_txid：300
> 3. 可见性算法规则：
>    1. row的txid 小于 min_txid ，则可见
>    2. row的txid 大于 max_txid，则不可见
>    3. 其他情况时，需要额外判断：
>       1. 在未提交的事务id数组中，则不可见
>       2. 否则可见

**读已提交 事务隔离级别时，read_view 每次查询都会重新生成，所以能读取到最新的数据**

当前事务中发生update语句时，当前这条数据的读取，会变成当前读，从当前内存读取最新的数据

![image-20230210144715048](/mysql.assets/image-20230210144715048.png)

### 锁

- **性能上分类：乐观锁，悲观锁**

- **粒度上区分：表锁，页锁，行锁**，间隙锁

  - **表锁**：表级别的锁；并发度小，开销小，加锁快
    
    - lock table {tableName1} read(write),{tableName2} read(write);
    - show open tables; （in_use=1 表示加锁中）
    - unlock tables; 释放锁
    
  - 页锁：只有innodb存储引擎支持页锁
    - 某个page页的数据加锁，开销介于表锁和行锁之间
    
  - **行锁**：并发度高，开销大，加锁慢（因为需要找到具体的某一条数据）
    
    - innoDB 支持行级别锁
    
  - **Gap锁，间隙锁**
    
    - 两个id值之间的空隙，rr 隔离级别才能生效
    
    - 也就是说，只要在道障范围内锁了一条不存在的记录会锁住整个间隙范围，不锁边界记录，这样就能防止它Session在这个间隙范围内插入数据，就解决了可重复读隔离级别的幻读问题。
    
    - ```mysql
      -- 则(10,20)这个空的区间会锁住
      update account set a =1 where id =18
      ```
    
  - **临键锁**：行锁 + 间隙锁 ，组合就是`临键锁`

- **类型上区分：**

  - **读锁**（共享锁、S锁）：select ... lock in share mode
    - 是共享的，多个事务可以同时读取同一个资源，但不允许其他事物修改
  - **写锁**（排它锁，X锁）：select ... for update
    - 排它的，会阻塞其他的写锁和读锁，update、delete、insert 都会加写锁

- **意向锁**：mysql自己增加的，为了提高效率，当有一个session给加锁之后，会设置一个标识，其他session过来过发现已经被加锁，则不用再遍历数据，判断是否加锁

## 其他：

### 查询操作方法，需要使用事务吗？

> 看业务要求，以及事物隔离级别
>
> 如果默认的rr级别，最好增加事务，保证多条sql查询的结果都是 同一时间维度

### 事务优化时间原则

- 查询等操作可以考虑放到事务外
- 事务之中避免远程调用，远程调用增加超时设置
- 事务中避免一次性处理太多数据，可以考虑拆分成多个事务分词处理
- 更新等涉及加锁的操作尽可能放到事务靠后的位置
- 能异步处理，尽量异步处理

#### 问题排查

```mysql
-- 展示锁占用情况
show status like 'innodb_row_lock%'
```

## Mysql 日志

### redo log

执行 命令预写日志：wal机制



### binlog

记录所有修改的语句

- 数据恢复
  - 根据偏移量进行数据恢复
  - 根据时间范围进行数据恢复
- 从库复制

5.7 默认关闭，8 之后默认开启



二进制归档文件

### undo log

回滚日志，数据版本链条

